{"ast":null,"code":"const Transport = require(\"../transport\");\n\nconst zlib = require(\"zlib\");\n\nconst accepts = require(\"accepts\");\n\nconst debug = require(\"debug\")(\"engine:polling\");\n\nconst compressionMethods = {\n  gzip: zlib.createGzip,\n  deflate: zlib.createDeflate\n};\n\nclass Polling extends Transport {\n  /**\n   * HTTP polling constructor.\n   *\n   * @api public.\n   */\n  constructor(req) {\n    super(req);\n    this.closeTimeout = 30 * 1000;\n    this.maxHttpBufferSize = null;\n    this.httpCompression = null;\n  }\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n\n  get name() {\n    return \"polling\";\n  }\n  /**\n   * Overrides onRequest.\n   *\n   * @param {http.IncomingMessage}\n   * @api private\n   */\n\n\n  onRequest(req) {\n    const res = req.res;\n\n    if (\"GET\" === req.method) {\n      this.onPollRequest(req, res);\n    } else if (\"POST\" === req.method) {\n      this.onDataRequest(req, res);\n    } else {\n      res.writeHead(500);\n      res.end();\n    }\n  }\n  /**\n   * The client sends a request awaiting for us to send data.\n   *\n   * @api private\n   */\n\n\n  onPollRequest(req, res) {\n    if (this.req) {\n      debug(\"request overlap\"); // assert: this.res, '.req and .res should be (un)set together'\n\n      this.onError(\"overlap from client\");\n      res.writeHead(500);\n      res.end();\n      return;\n    }\n\n    debug(\"setting request\");\n    this.req = req;\n    this.res = res;\n    const self = this;\n\n    function onClose() {\n      self.onError(\"poll connection closed prematurely\");\n    }\n\n    function cleanup() {\n      req.removeListener(\"close\", onClose);\n      self.req = self.res = null;\n    }\n\n    req.cleanup = cleanup;\n    req.on(\"close\", onClose);\n    this.writable = true;\n    this.emit(\"drain\"); // if we're still writable but had a pending close, trigger an empty send\n\n    if (this.writable && this.shouldClose) {\n      debug(\"triggering empty send to append close packet\");\n      this.send([{\n        type: \"noop\"\n      }]);\n    }\n  }\n  /**\n   * The client sends a request with data.\n   *\n   * @api private\n   */\n\n\n  onDataRequest(req, res) {\n    if (this.dataReq) {\n      // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n      this.onError(\"data request overlap from client\");\n      res.writeHead(500);\n      res.end();\n      return;\n    }\n\n    const isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\n\n    if (isBinary && this.protocol === 4) {\n      return this.onError(\"invalid content\");\n    }\n\n    this.dataReq = req;\n    this.dataRes = res;\n    let chunks = isBinary ? Buffer.concat([]) : \"\";\n    const self = this;\n\n    function cleanup() {\n      req.removeListener(\"data\", onData);\n      req.removeListener(\"end\", onEnd);\n      req.removeListener(\"close\", onClose);\n      self.dataReq = self.dataRes = chunks = null;\n    }\n\n    function onClose() {\n      cleanup();\n      self.onError(\"data request connection closed prematurely\");\n    }\n\n    function onData(data) {\n      let contentLength;\n\n      if (isBinary) {\n        chunks = Buffer.concat([chunks, data]);\n        contentLength = chunks.length;\n      } else {\n        chunks += data;\n        contentLength = Buffer.byteLength(chunks);\n      }\n\n      if (contentLength > self.maxHttpBufferSize) {\n        chunks = isBinary ? Buffer.concat([]) : \"\";\n        req.connection.destroy();\n      }\n    }\n\n    function onEnd() {\n      self.onData(chunks);\n      const headers = {\n        // text/html is required instead of text/plain to avoid an\n        // unwanted download dialog on certain user-agents (GH-43)\n        \"Content-Type\": \"text/html\",\n        \"Content-Length\": 2\n      };\n      res.writeHead(200, self.headers(req, headers));\n      res.end(\"ok\");\n      cleanup();\n    }\n\n    req.on(\"close\", onClose);\n    if (!isBinary) req.setEncoding(\"utf8\");\n    req.on(\"data\", onData);\n    req.on(\"end\", onEnd);\n  }\n  /**\n   * Processes the incoming data payload.\n   *\n   * @param {String} encoded payload\n   * @api private\n   */\n\n\n  onData(data) {\n    debug('received \"%s\"', data);\n    const self = this;\n\n    const callback = function (packet) {\n      if (\"close\" === packet.type) {\n        debug(\"got xhr close packet\");\n        self.onClose();\n        return false;\n      }\n\n      self.onPacket(packet);\n    };\n\n    if (this.protocol === 3) {\n      this.parser.decodePayload(data, callback);\n    } else {\n      this.parser.decodePayload(data).forEach(callback);\n    }\n  }\n  /**\n   * Overrides onClose.\n   *\n   * @api private\n   */\n\n\n  onClose() {\n    if (this.writable) {\n      // close pending poll request\n      this.send([{\n        type: \"noop\"\n      }]);\n    }\n\n    super.onClose();\n  }\n  /**\n   * Writes a packet payload.\n   *\n   * @param {Object} packet\n   * @api private\n   */\n\n\n  send(packets) {\n    this.writable = false;\n\n    if (this.shouldClose) {\n      debug(\"appending close packet to payload\");\n      packets.push({\n        type: \"close\"\n      });\n      this.shouldClose();\n      this.shouldClose = null;\n    }\n\n    const doWrite = data => {\n      const compress = packets.some(packet => {\n        return packet.options && packet.options.compress;\n      });\n      this.write(data, {\n        compress\n      });\n    };\n\n    if (this.protocol === 3) {\n      this.parser.encodePayload(packets, this.supportsBinary, doWrite);\n    } else {\n      this.parser.encodePayload(packets, doWrite);\n    }\n  }\n  /**\n   * Writes data as response to poll request.\n   *\n   * @param {String} data\n   * @param {Object} options\n   * @api private\n   */\n\n\n  write(data, options) {\n    debug('writing \"%s\"', data);\n    const self = this;\n    this.doWrite(data, options, function () {\n      self.req.cleanup();\n    });\n  }\n  /**\n   * Performs the write.\n   *\n   * @api private\n   */\n\n\n  doWrite(data, options, callback) {\n    const self = this; // explicit UTF-8 is required for pages not served under utf\n\n    const isString = typeof data === \"string\";\n    const contentType = isString ? \"text/plain; charset=UTF-8\" : \"application/octet-stream\";\n    const headers = {\n      \"Content-Type\": contentType\n    };\n\n    if (!this.httpCompression || !options.compress) {\n      respond(data);\n      return;\n    }\n\n    const len = isString ? Buffer.byteLength(data) : data.length;\n\n    if (len < this.httpCompression.threshold) {\n      respond(data);\n      return;\n    }\n\n    const encoding = accepts(this.req).encodings([\"gzip\", \"deflate\"]);\n\n    if (!encoding) {\n      respond(data);\n      return;\n    }\n\n    this.compress(data, encoding, function (err, data) {\n      if (err) {\n        self.res.writeHead(500);\n        self.res.end();\n        callback(err);\n        return;\n      }\n\n      headers[\"Content-Encoding\"] = encoding;\n      respond(data);\n    });\n\n    function respond(data) {\n      headers[\"Content-Length\"] = \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n      self.res.writeHead(200, self.headers(self.req, headers));\n      self.res.end(data);\n      callback();\n    }\n  }\n  /**\n   * Compresses data.\n   *\n   * @api private\n   */\n\n\n  compress(data, encoding, callback) {\n    debug(\"compressing\");\n    const buffers = [];\n    let nread = 0;\n    compressionMethods[encoding](this.httpCompression).on(\"error\", callback).on(\"data\", function (chunk) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }).on(\"end\", function () {\n      callback(null, Buffer.concat(buffers, nread));\n    }).end(data);\n  }\n  /**\n   * Closes the transport.\n   *\n   * @api private\n   */\n\n\n  doClose(fn) {\n    debug(\"closing\");\n    const self = this;\n    let closeTimeoutTimer;\n\n    if (this.dataReq) {\n      debug(\"aborting ongoing data request\");\n      this.dataReq.destroy();\n    }\n\n    if (this.writable) {\n      debug(\"transport writable - closing right away\");\n      this.send([{\n        type: \"close\"\n      }]);\n      onClose();\n    } else if (this.discarded) {\n      debug(\"transport discarded - closing right away\");\n      onClose();\n    } else {\n      debug(\"transport not writable - buffering orderly close\");\n      this.shouldClose = onClose;\n      closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n    }\n\n    function onClose() {\n      clearTimeout(closeTimeoutTimer);\n      fn();\n      self.onClose();\n    }\n  }\n  /**\n   * Returns headers for a response.\n   *\n   * @param {http.IncomingMessage} request\n   * @param {Object} extra headers\n   * @api private\n   */\n\n\n  headers(req, headers) {\n    headers = headers || {}; // prevent XSS warnings on IE\n    // https://github.com/LearnBoost/socket.io/pull/1333\n\n    const ua = req.headers[\"user-agent\"];\n\n    if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n      headers[\"X-XSS-Protection\"] = \"0\";\n    }\n\n    this.emit(\"headers\", headers);\n    return headers;\n  }\n\n}\n\nmodule.exports = Polling;","map":{"version":3,"sources":["C:/Users/elsow/Documents/React Projects/videoChatApp/node_modules/engine.io/lib/transports/polling.js"],"names":["Transport","require","zlib","accepts","debug","compressionMethods","gzip","createGzip","deflate","createDeflate","Polling","constructor","req","closeTimeout","maxHttpBufferSize","httpCompression","name","onRequest","res","method","onPollRequest","onDataRequest","writeHead","end","onError","self","onClose","cleanup","removeListener","on","writable","emit","shouldClose","send","type","dataReq","isBinary","headers","protocol","dataRes","chunks","Buffer","concat","onData","onEnd","data","contentLength","length","byteLength","connection","destroy","setEncoding","callback","packet","onPacket","parser","decodePayload","forEach","packets","push","doWrite","compress","some","options","write","encodePayload","supportsBinary","isString","contentType","respond","len","threshold","encoding","encodings","err","buffers","nread","chunk","doClose","fn","closeTimeoutTimer","discarded","setTimeout","clearTimeout","ua","indexOf","module","exports"],"mappings":"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","sourcesContent":["const Transport = require(\"../transport\");\nconst zlib = require(\"zlib\");\nconst accepts = require(\"accepts\");\nconst debug = require(\"debug\")(\"engine:polling\");\n\nconst compressionMethods = {\n  gzip: zlib.createGzip,\n  deflate: zlib.createDeflate\n};\n\nclass Polling extends Transport {\n  /**\n   * HTTP polling constructor.\n   *\n   * @api public.\n   */\n  constructor(req) {\n    super(req);\n\n    this.closeTimeout = 30 * 1000;\n    this.maxHttpBufferSize = null;\n    this.httpCompression = null;\n  }\n\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n  get name() {\n    return \"polling\";\n  }\n\n  /**\n   * Overrides onRequest.\n   *\n   * @param {http.IncomingMessage}\n   * @api private\n   */\n  onRequest(req) {\n    const res = req.res;\n\n    if (\"GET\" === req.method) {\n      this.onPollRequest(req, res);\n    } else if (\"POST\" === req.method) {\n      this.onDataRequest(req, res);\n    } else {\n      res.writeHead(500);\n      res.end();\n    }\n  }\n\n  /**\n   * The client sends a request awaiting for us to send data.\n   *\n   * @api private\n   */\n  onPollRequest(req, res) {\n    if (this.req) {\n      debug(\"request overlap\");\n      // assert: this.res, '.req and .res should be (un)set together'\n      this.onError(\"overlap from client\");\n      res.writeHead(500);\n      res.end();\n      return;\n    }\n\n    debug(\"setting request\");\n\n    this.req = req;\n    this.res = res;\n\n    const self = this;\n\n    function onClose() {\n      self.onError(\"poll connection closed prematurely\");\n    }\n\n    function cleanup() {\n      req.removeListener(\"close\", onClose);\n      self.req = self.res = null;\n    }\n\n    req.cleanup = cleanup;\n    req.on(\"close\", onClose);\n\n    this.writable = true;\n    this.emit(\"drain\");\n\n    // if we're still writable but had a pending close, trigger an empty send\n    if (this.writable && this.shouldClose) {\n      debug(\"triggering empty send to append close packet\");\n      this.send([{ type: \"noop\" }]);\n    }\n  }\n\n  /**\n   * The client sends a request with data.\n   *\n   * @api private\n   */\n  onDataRequest(req, res) {\n    if (this.dataReq) {\n      // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n      this.onError(\"data request overlap from client\");\n      res.writeHead(500);\n      res.end();\n      return;\n    }\n\n    const isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\n\n    if (isBinary && this.protocol === 4) {\n      return this.onError(\"invalid content\");\n    }\n\n    this.dataReq = req;\n    this.dataRes = res;\n\n    let chunks = isBinary ? Buffer.concat([]) : \"\";\n    const self = this;\n\n    function cleanup() {\n      req.removeListener(\"data\", onData);\n      req.removeListener(\"end\", onEnd);\n      req.removeListener(\"close\", onClose);\n      self.dataReq = self.dataRes = chunks = null;\n    }\n\n    function onClose() {\n      cleanup();\n      self.onError(\"data request connection closed prematurely\");\n    }\n\n    function onData(data) {\n      let contentLength;\n      if (isBinary) {\n        chunks = Buffer.concat([chunks, data]);\n        contentLength = chunks.length;\n      } else {\n        chunks += data;\n        contentLength = Buffer.byteLength(chunks);\n      }\n\n      if (contentLength > self.maxHttpBufferSize) {\n        chunks = isBinary ? Buffer.concat([]) : \"\";\n        req.connection.destroy();\n      }\n    }\n\n    function onEnd() {\n      self.onData(chunks);\n\n      const headers = {\n        // text/html is required instead of text/plain to avoid an\n        // unwanted download dialog on certain user-agents (GH-43)\n        \"Content-Type\": \"text/html\",\n        \"Content-Length\": 2\n      };\n\n      res.writeHead(200, self.headers(req, headers));\n      res.end(\"ok\");\n      cleanup();\n    }\n\n    req.on(\"close\", onClose);\n    if (!isBinary) req.setEncoding(\"utf8\");\n    req.on(\"data\", onData);\n    req.on(\"end\", onEnd);\n  }\n\n  /**\n   * Processes the incoming data payload.\n   *\n   * @param {String} encoded payload\n   * @api private\n   */\n  onData(data) {\n    debug('received \"%s\"', data);\n    const self = this;\n    const callback = function(packet) {\n      if (\"close\" === packet.type) {\n        debug(\"got xhr close packet\");\n        self.onClose();\n        return false;\n      }\n\n      self.onPacket(packet);\n    };\n\n    if (this.protocol === 3) {\n      this.parser.decodePayload(data, callback);\n    } else {\n      this.parser.decodePayload(data).forEach(callback);\n    }\n  }\n\n  /**\n   * Overrides onClose.\n   *\n   * @api private\n   */\n  onClose() {\n    if (this.writable) {\n      // close pending poll request\n      this.send([{ type: \"noop\" }]);\n    }\n    super.onClose();\n  }\n\n  /**\n   * Writes a packet payload.\n   *\n   * @param {Object} packet\n   * @api private\n   */\n  send(packets) {\n    this.writable = false;\n\n    if (this.shouldClose) {\n      debug(\"appending close packet to payload\");\n      packets.push({ type: \"close\" });\n      this.shouldClose();\n      this.shouldClose = null;\n    }\n\n    const doWrite = data => {\n      const compress = packets.some(packet => {\n        return packet.options && packet.options.compress;\n      });\n      this.write(data, { compress });\n    };\n\n    if (this.protocol === 3) {\n      this.parser.encodePayload(packets, this.supportsBinary, doWrite);\n    } else {\n      this.parser.encodePayload(packets, doWrite);\n    }\n  }\n\n  /**\n   * Writes data as response to poll request.\n   *\n   * @param {String} data\n   * @param {Object} options\n   * @api private\n   */\n  write(data, options) {\n    debug('writing \"%s\"', data);\n    const self = this;\n    this.doWrite(data, options, function() {\n      self.req.cleanup();\n    });\n  }\n\n  /**\n   * Performs the write.\n   *\n   * @api private\n   */\n  doWrite(data, options, callback) {\n    const self = this;\n\n    // explicit UTF-8 is required for pages not served under utf\n    const isString = typeof data === \"string\";\n    const contentType = isString\n      ? \"text/plain; charset=UTF-8\"\n      : \"application/octet-stream\";\n\n    const headers = {\n      \"Content-Type\": contentType\n    };\n\n    if (!this.httpCompression || !options.compress) {\n      respond(data);\n      return;\n    }\n\n    const len = isString ? Buffer.byteLength(data) : data.length;\n    if (len < this.httpCompression.threshold) {\n      respond(data);\n      return;\n    }\n\n    const encoding = accepts(this.req).encodings([\"gzip\", \"deflate\"]);\n    if (!encoding) {\n      respond(data);\n      return;\n    }\n\n    this.compress(data, encoding, function(err, data) {\n      if (err) {\n        self.res.writeHead(500);\n        self.res.end();\n        callback(err);\n        return;\n      }\n\n      headers[\"Content-Encoding\"] = encoding;\n      respond(data);\n    });\n\n    function respond(data) {\n      headers[\"Content-Length\"] =\n        \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n      self.res.writeHead(200, self.headers(self.req, headers));\n      self.res.end(data);\n      callback();\n    }\n  }\n\n  /**\n   * Compresses data.\n   *\n   * @api private\n   */\n  compress(data, encoding, callback) {\n    debug(\"compressing\");\n\n    const buffers = [];\n    let nread = 0;\n\n    compressionMethods[encoding](this.httpCompression)\n      .on(\"error\", callback)\n      .on(\"data\", function(chunk) {\n        buffers.push(chunk);\n        nread += chunk.length;\n      })\n      .on(\"end\", function() {\n        callback(null, Buffer.concat(buffers, nread));\n      })\n      .end(data);\n  }\n\n  /**\n   * Closes the transport.\n   *\n   * @api private\n   */\n  doClose(fn) {\n    debug(\"closing\");\n\n    const self = this;\n    let closeTimeoutTimer;\n\n    if (this.dataReq) {\n      debug(\"aborting ongoing data request\");\n      this.dataReq.destroy();\n    }\n\n    if (this.writable) {\n      debug(\"transport writable - closing right away\");\n      this.send([{ type: \"close\" }]);\n      onClose();\n    } else if (this.discarded) {\n      debug(\"transport discarded - closing right away\");\n      onClose();\n    } else {\n      debug(\"transport not writable - buffering orderly close\");\n      this.shouldClose = onClose;\n      closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n    }\n\n    function onClose() {\n      clearTimeout(closeTimeoutTimer);\n      fn();\n      self.onClose();\n    }\n  }\n\n  /**\n   * Returns headers for a response.\n   *\n   * @param {http.IncomingMessage} request\n   * @param {Object} extra headers\n   * @api private\n   */\n  headers(req, headers) {\n    headers = headers || {};\n\n    // prevent XSS warnings on IE\n    // https://github.com/LearnBoost/socket.io/pull/1333\n    const ua = req.headers[\"user-agent\"];\n    if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n      headers[\"X-XSS-Protection\"] = \"0\";\n    }\n\n    this.emit(\"headers\", headers);\n    return headers;\n  }\n}\n\nmodule.exports = Polling;\n"]},"metadata":{},"sourceType":"script"}