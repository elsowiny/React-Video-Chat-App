{"ast":null,"code":"// imported from https://github.com/socketio/engine.io-parser/tree/2.2.x\n\n/**\n * Module dependencies.\n */\nvar utf8 = require('./utf8');\n/**\n * Current protocol version.\n */\n\n\nexports.protocol = 3;\n\nconst hasBinary = packets => {\n  for (const packet of packets) {\n    if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Packet types.\n */\n\n\nvar packets = exports.packets = {\n  open: 0 // non-ws\n  ,\n  close: 1 // non-ws\n  ,\n  ping: 2,\n  pong: 3,\n  message: 4,\n  upgrade: 5,\n  noop: 6\n};\nvar packetslist = Object.keys(packets);\n/**\n * Premade error packet.\n */\n\nvar err = {\n  type: 'error',\n  data: 'parser error'\n};\nconst EMPTY_BUFFER = Buffer.concat([]);\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  if (typeof utf8encode === 'function') {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  if (Buffer.isBuffer(packet.data)) {\n    return encodeBuffer(packet, supportsBinary, callback);\n  } else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {\n    return encodeBuffer({\n      type: packet.type,\n      data: arrayBufferToBuffer(packet.data)\n    }, supportsBinary, callback);\n  } // Sending data as a utf-8 string\n\n\n  var encoded = packets[packet.type]; // data fragment is optional\n\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data), {\n      strict: false\n    }) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n};\n/**\n * Encode Buffer data\n */\n\n\nfunction encodeBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var typeBuffer = Buffer.allocUnsafe(1);\n  typeBuffer[0] = packets[packet.type];\n  return callback(Buffer.concat([typeBuffer, data]));\n}\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\n\nexports.encodeBase64Packet = function (packet, callback) {\n  var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);\n  var message = 'b' + packets[packet.type];\n  message += data.toString('base64');\n  return callback(message);\n};\n/**\n * Decodes a packet. Data also available as an ArrayBuffer if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\n\nexports.decodePacket = function (data, binaryType, utf8decode) {\n  if (data === undefined) {\n    return err;\n  }\n\n  var type; // String data\n\n  if (typeof data === 'string') {\n    type = data.charAt(0);\n\n    if (type === 'b') {\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\n    }\n\n    if (utf8decode) {\n      data = tryDecode(data);\n\n      if (data === false) {\n        return err;\n      }\n    }\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return {\n        type: packetslist[type],\n        data: data.substring(1)\n      };\n    } else {\n      return {\n        type: packetslist[type]\n      };\n    }\n  } // Binary data\n\n\n  if (binaryType === 'arraybuffer') {\n    // wrap Buffer/ArrayBuffer data into an Uint8Array\n    var intArray = new Uint8Array(data);\n    type = intArray[0];\n    return {\n      type: packetslist[type],\n      data: intArray.buffer.slice(1)\n    };\n  }\n\n  if (data instanceof ArrayBuffer) {\n    data = arrayBufferToBuffer(data);\n  }\n\n  type = data[0];\n  return {\n    type: packetslist[type],\n    data: data.slice(1)\n  };\n};\n\nfunction tryDecode(data) {\n  try {\n    data = utf8.decode(data, {\n      strict: false\n    });\n  } catch (e) {\n    return false;\n  }\n\n  return data;\n}\n/**\n * Decodes a packet encoded in a base64 string.\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\n\nexports.decodeBase64Packet = function (msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  var data = Buffer.from(msg.substr(1), 'base64');\n\n  if (binaryType === 'arraybuffer') {\n    var abv = new Uint8Array(data.length);\n\n    for (var i = 0; i < abv.length; i++) {\n      abv[i] = data[i];\n    }\n\n    data = abv.buffer;\n  }\n\n  return {\n    type: type,\n    data: data\n  };\n};\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\n\nexports.encodePayload = function (packets, supportsBinary, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  if (supportsBinary && hasBinary(packets)) {\n    return exports.encodePayloadAsBinary(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, supportsBinary, false, function (message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function (err, results) {\n    return callback(results.join(''));\n  });\n};\n\nfunction setLengthHeader(message) {\n  return message.length + ':' + message;\n}\n/**\n * Async array map using after\n */\n\n\nfunction map(ary, each, done) {\n  const results = new Array(ary.length);\n  let count = 0;\n\n  for (let i = 0; i < ary.length; i++) {\n    each(ary[i], (error, msg) => {\n      results[i] = msg;\n\n      if (++count === ary.length) {\n        done(null, results);\n      }\n    });\n  }\n}\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\n\nexports.decodePayload = function (data, binaryType, callback) {\n  if (typeof data !== 'string') {\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  if (data === '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = '',\n      n,\n      msg,\n      packet;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (chr !== ':') {\n      length += chr;\n      continue;\n    }\n\n    if (length === '' || length != (n = Number(length))) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    msg = data.substr(i + 1, n);\n\n    if (length != msg.length) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    if (msg.length) {\n      packet = exports.decodePacket(msg, binaryType, false);\n\n      if (err.type === packet.type && err.data === packet.data) {\n        // parser error in individual packet - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      var more = callback(packet, i + n, l);\n      if (false === more) return;\n    } // advance cursor\n\n\n    i += n;\n    length = '';\n  }\n\n  if (length !== '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n};\n/**\n *\n * Converts a buffer to a utf8.js encoded string\n *\n * @api private\n */\n\n\nfunction bufferToString(buffer) {\n  var str = '';\n\n  for (var i = 0, l = buffer.length; i < l; i++) {\n    str += String.fromCharCode(buffer[i]);\n  }\n\n  return str;\n}\n/**\n *\n * Converts a utf8.js encoded string to a buffer\n *\n * @api private\n */\n\n\nfunction stringToBuffer(string) {\n  var buf = Buffer.allocUnsafe(string.length);\n\n  for (var i = 0, l = string.length; i < l; i++) {\n    buf.writeUInt8(string.charCodeAt(i), i);\n  }\n\n  return buf;\n}\n/**\n *\n * Converts an ArrayBuffer to a Buffer\n *\n * @api private\n */\n\n\nfunction arrayBufferToBuffer(data) {\n  // data is either an ArrayBuffer or ArrayBufferView.\n  var length = data.byteLength || data.length;\n  var offset = data.byteOffset || 0;\n  return Buffer.from(data.buffer || data, offset, length);\n}\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {Buffer} encoded payload\n * @api private\n */\n\n\nexports.encodePayloadAsBinary = function (packets, callback) {\n  if (!packets.length) {\n    return callback(EMPTY_BUFFER);\n  }\n\n  map(packets, encodeOneBinaryPacket, function (err, results) {\n    return callback(Buffer.concat(results));\n  });\n};\n\nfunction encodeOneBinaryPacket(p, doneCallback) {\n  function onBinaryPacketEncode(packet) {\n    var encodingLength = '' + packet.length;\n    var sizeBuffer;\n\n    if (typeof packet === 'string') {\n      sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n      sizeBuffer[0] = 0; // is a string (not true binary = 0)\n\n      for (var i = 0; i < encodingLength.length; i++) {\n        sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n      }\n\n      sizeBuffer[sizeBuffer.length - 1] = 255;\n      return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));\n    }\n\n    sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n    sizeBuffer[0] = 1; // is binary (true binary = 1)\n\n    for (var i = 0; i < encodingLength.length; i++) {\n      sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n    }\n\n    sizeBuffer[sizeBuffer.length - 1] = 255;\n    doneCallback(null, Buffer.concat([sizeBuffer, packet]));\n  }\n\n  exports.encodePacket(p, true, true, onBinaryPacketEncode);\n}\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n\n * @param {Buffer} data, callback method\n * @api public\n */\n\n\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n  var i;\n\n  while (bufferTail.length > 0) {\n    var strLen = '';\n    var isString = bufferTail[0] === 0;\n\n    for (i = 1;; i++) {\n      if (bufferTail[i] === 255) break; // 310 = char length of Number.MAX_VALUE\n\n      if (strLen.length > 310) {\n        return callback(err, 0, 1);\n      }\n\n      strLen += '' + bufferTail[i];\n    }\n\n    bufferTail = bufferTail.slice(strLen.length + 1);\n    var msgLength = parseInt(strLen, 10);\n    var msg = bufferTail.slice(1, msgLength + 1);\n    if (isString) msg = bufferToString(msg);\n    buffers.push(msg);\n    bufferTail = bufferTail.slice(msgLength + 1);\n  }\n\n  var total = buffers.length;\n\n  for (i = 0; i < total; i++) {\n    var buffer = buffers[i];\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n  }\n};","map":{"version":3,"sources":["C:/Users/elsow/Documents/React Projects/videoChatApp/node_modules/engine.io/lib/parser-v3/index.js"],"names":["utf8","require","exports","protocol","hasBinary","packets","packet","data","ArrayBuffer","isView","open","close","ping","pong","message","upgrade","noop","packetslist","Object","keys","err","type","EMPTY_BUFFER","Buffer","concat","encodePacket","supportsBinary","utf8encode","callback","isBuffer","encodeBuffer","buffer","arrayBufferToBuffer","encoded","undefined","encode","String","strict","encodeBase64Packet","typeBuffer","allocUnsafe","toString","decodePacket","binaryType","utf8decode","charAt","decodeBase64Packet","substr","tryDecode","Number","length","substring","intArray","Uint8Array","slice","decode","e","msg","from","abv","i","encodePayload","encodePayloadAsBinary","encodeOne","doneCallback","setLengthHeader","map","results","join","ary","each","done","Array","count","error","decodePayload","decodePayloadAsBinary","n","l","chr","more","bufferToString","str","fromCharCode","stringToBuffer","string","buf","writeUInt8","charCodeAt","byteLength","offset","byteOffset","encodeOneBinaryPacket","p","onBinaryPacketEncode","encodingLength","sizeBuffer","parseInt","bufferTail","buffers","strLen","isString","msgLength","push","total"],"mappings":"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","sourcesContent":["// imported from https://github.com/socketio/engine.io-parser/tree/2.2.x\n\n/**\n * Module dependencies.\n */\n\nvar utf8 = require('./utf8');\n\n/**\n * Current protocol version.\n */\nexports.protocol = 3;\n\nconst hasBinary = (packets) => {\n  for (const packet of packets) {\n    if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Packet types.\n */\n\nvar packets = exports.packets = {\n    open:     0    // non-ws\n  , close:    1    // non-ws\n  , ping:     2\n  , pong:     3\n  , message:  4\n  , upgrade:  5\n  , noop:     6\n};\n\nvar packetslist = Object.keys(packets);\n\n/**\n * Premade error packet.\n */\n\nvar err = { type: 'error', data: 'parser error' };\n\nconst EMPTY_BUFFER = Buffer.concat([]);\n\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  if (typeof utf8encode === 'function') {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  if (Buffer.isBuffer(packet.data)) {\n    return encodeBuffer(packet, supportsBinary, callback);\n  } else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {\n    return encodeBuffer({ type: packet.type, data: arrayBufferToBuffer(packet.data) }, supportsBinary, callback);\n  }\n\n  // Sending data as a utf-8 string\n  var encoded = packets[packet.type];\n\n  // data fragment is optional\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n};\n\n/**\n * Encode Buffer data\n */\n\nfunction encodeBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var typeBuffer = Buffer.allocUnsafe(1);\n  typeBuffer[0] = packets[packet.type];\n  return callback(Buffer.concat([typeBuffer, data]));\n}\n\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\nexports.encodeBase64Packet = function(packet, callback){\n  var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);\n  var message = 'b' + packets[packet.type];\n  message += data.toString('base64');\n  return callback(message);\n};\n\n/**\n * Decodes a packet. Data also available as an ArrayBuffer if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\nexports.decodePacket = function (data, binaryType, utf8decode) {\n  if (data === undefined) {\n    return err;\n  }\n\n  var type;\n\n  // String data\n  if (typeof data === 'string') {\n\n    type = data.charAt(0);\n\n    if (type === 'b') {\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\n    }\n\n    if (utf8decode) {\n      data = tryDecode(data);\n      if (data === false) {\n        return err;\n      }\n    }\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return { type: packetslist[type], data: data.substring(1) };\n    } else {\n      return { type: packetslist[type] };\n    }\n  }\n\n  // Binary data\n  if (binaryType === 'arraybuffer') {\n    // wrap Buffer/ArrayBuffer data into an Uint8Array\n    var intArray = new Uint8Array(data);\n    type = intArray[0];\n    return { type: packetslist[type], data: intArray.buffer.slice(1) };\n  }\n\n  if (data instanceof ArrayBuffer) {\n    data = arrayBufferToBuffer(data);\n  }\n  type = data[0];\n  return { type: packetslist[type], data: data.slice(1) };\n};\n\nfunction tryDecode(data) {\n  try {\n    data = utf8.decode(data, { strict: false });\n  } catch (e) {\n    return false;\n  }\n  return data;\n}\n\n/**\n * Decodes a packet encoded in a base64 string.\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\nexports.decodeBase64Packet = function(msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  var data = Buffer.from(msg.substr(1), 'base64');\n  if (binaryType === 'arraybuffer') {\n    var abv = new Uint8Array(data.length);\n    for (var i = 0; i < abv.length; i++){\n      abv[i] = data[i];\n    }\n    data = abv.buffer;\n  }\n  return { type: type, data: data };\n};\n\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\nexports.encodePayload = function (packets, supportsBinary, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  if (supportsBinary && hasBinary(packets)) {\n    return exports.encodePayloadAsBinary(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, supportsBinary, false, function(message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(results.join(''));\n  });\n};\n\nfunction setLengthHeader(message) {\n  return message.length + ':' + message;\n}\n\n/**\n * Async array map using after\n */\n\nfunction map(ary, each, done) {\n  const results = new Array(ary.length);\n  let count = 0;\n\n  for (let i = 0; i < ary.length; i++) {\n    each(ary[i], (error, msg) => {\n      results[i] = msg;\n      if (++count === ary.length) {\n        done(null, results);\n      }\n    });\n  }\n}\n\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\nexports.decodePayload = function (data, binaryType, callback) {\n  if (typeof data !== 'string') {\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  if (data === '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = '', n, msg, packet;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (chr !== ':') {\n      length += chr;\n      continue;\n    }\n\n    if (length === '' || (length != (n = Number(length)))) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    msg = data.substr(i + 1, n);\n\n    if (length != msg.length) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    if (msg.length) {\n      packet = exports.decodePacket(msg, binaryType, false);\n\n      if (err.type === packet.type && err.data === packet.data) {\n        // parser error in individual packet - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      var more = callback(packet, i + n, l);\n      if (false === more) return;\n    }\n\n    // advance cursor\n    i += n;\n    length = '';\n  }\n\n  if (length !== '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n};\n\n/**\n *\n * Converts a buffer to a utf8.js encoded string\n *\n * @api private\n */\n\nfunction bufferToString(buffer) {\n  var str = '';\n  for (var i = 0, l = buffer.length; i < l; i++) {\n    str += String.fromCharCode(buffer[i]);\n  }\n  return str;\n}\n\n/**\n *\n * Converts a utf8.js encoded string to a buffer\n *\n * @api private\n */\n\nfunction stringToBuffer(string) {\n  var buf = Buffer.allocUnsafe(string.length);\n  for (var i = 0, l = string.length; i < l; i++) {\n    buf.writeUInt8(string.charCodeAt(i), i);\n  }\n  return buf;\n}\n\n/**\n *\n * Converts an ArrayBuffer to a Buffer\n *\n * @api private\n */\n\nfunction arrayBufferToBuffer(data) {\n  // data is either an ArrayBuffer or ArrayBufferView.\n  var length = data.byteLength || data.length;\n  var offset = data.byteOffset || 0;\n\n  return Buffer.from(data.buffer || data, offset, length);\n}\n\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {Buffer} encoded payload\n * @api private\n */\n\nexports.encodePayloadAsBinary = function (packets, callback) {\n  if (!packets.length) {\n    return callback(EMPTY_BUFFER);\n  }\n\n  map(packets, encodeOneBinaryPacket, function(err, results) {\n    return callback(Buffer.concat(results));\n  });\n};\n\nfunction encodeOneBinaryPacket(p, doneCallback) {\n\n  function onBinaryPacketEncode(packet) {\n\n    var encodingLength = '' + packet.length;\n    var sizeBuffer;\n\n    if (typeof packet === 'string') {\n      sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n      sizeBuffer[0] = 0; // is a string (not true binary = 0)\n      for (var i = 0; i < encodingLength.length; i++) {\n        sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n      }\n      sizeBuffer[sizeBuffer.length - 1] = 255;\n      return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));\n    }\n\n    sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n    sizeBuffer[0] = 1; // is binary (true binary = 1)\n    for (var i = 0; i < encodingLength.length; i++) {\n      sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n    }\n    sizeBuffer[sizeBuffer.length - 1] = 255;\n\n    doneCallback(null, Buffer.concat([sizeBuffer, packet]));\n  }\n\n  exports.encodePacket(p, true, true, onBinaryPacketEncode);\n\n}\n\n\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n\n * @param {Buffer} data, callback method\n * @api public\n */\n\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n  var i;\n\n  while (bufferTail.length > 0) {\n    var strLen = '';\n    var isString = bufferTail[0] === 0;\n    for (i = 1; ; i++) {\n      if (bufferTail[i] === 255)  break;\n      // 310 = char length of Number.MAX_VALUE\n      if (strLen.length > 310) {\n        return callback(err, 0, 1);\n      }\n      strLen += '' + bufferTail[i];\n    }\n    bufferTail = bufferTail.slice(strLen.length + 1);\n\n    var msgLength = parseInt(strLen, 10);\n\n    var msg = bufferTail.slice(1, msgLength + 1);\n    if (isString) msg = bufferToString(msg);\n    buffers.push(msg);\n    bufferTail = bufferTail.slice(msgLength + 1);\n  }\n\n  var total = buffers.length;\n  for (i = 0; i < total; i++) {\n    var buffer = buffers[i];\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}